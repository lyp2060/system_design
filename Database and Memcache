migration: SQL needs to run migration scripts if you add one more column,
No SQL, is not schema format, no need to do that 

查询功能是用的最多的,for example, you look at your friends' profile 


注册时写请求
登入， 有时候是写请求，确定上次是什么时候登入的

QPS 决定存储系统的选择

mySQL:1K QPS. 实际中100 左右

mongoDB/Casssandra: 10K QPS 
can use range queries

Redis--》 支持数据持久化
Memcached: 100k-1m QPS ---》 断电了就没了
 基于内存，只能给定ID，才能给结果
 only works for key-value, no range queries 
 
 service:
 those mapping to 3 tables in SQL
 1. authservice
 2. userservice
 3. friendshipservice
 
 一个读多写少的系统，一定要用cache 进行优化
 
 
 browser cache: local storage, 静态文件的cache , 比如说图片
 
 cookie 不是cache, 每次request网站，都会查cookie, 会越来越慢
 
  CDN is cache too, in network side 
  
 cache always in db?
 no, can be used in frontend, browser too
 
 broswers use hash value to identify if the content is different, if different, browser is forced to re-download 
 

 
 memcached:
 一款负责帮你cache在内存里的软件，非常广泛使用在数据库系统中
 
 cache 有ttl, 有淘汰机制
 
  database, cache, web service 可能在3 个机器上
  
 cache and db maybe on differnet machines
 
 if the first operation failed, the whole operation will re-do, no issues
 issue is if the first operation is succesful, the second operation failed 
 
 A: database.set(user), cache.set(key,user)： if database失败，cache 里会有脏数据
 B: cache.set(key,user), database.set(user)： same as A
 C:cache.delete(key,user),database.set(user)， sometimeuse, no dirty data 
 D: database.set(user),cache.delete(key,user), will have dirty data  if cannt delete cache 
 
 严格说都错, C 中，当同时有很多用户访问database, 会出现race condition, facebook didnot use this way
 for example:
 
 def getUser(self,user_id):
  key = 'user::%s' %user_id
  user = cache.get(key)
  if user:
   return user
  user = database.get(user_id)
  cache.set(key,user)
  return user
  
 def setUser(self, user):
  key = 'user::%s" %user.id
  cache.delete(key)
  database.set(user)
  
 if in setUser function, after getUser get(user_id), another people use setuesr function to delete and databa.set , this will make cache has dirty data
 

 
 session table 存在serve端， 
 session_key, user_id, expire_at (默认3个月过期）
 
 session key, it was generated by web server, the hash value is unique.
 返回给浏览器，浏览器存在cookie 中， 一个用户有时候session 有多个，可能在safali 登入，也在chrome登入
 session table:
 session_key string
 user_id: foreign key
 expire_at: timestamp
 
 logout: 
 session table to delete the users session info 
 
 session_table 存在缓存，或者数据库 （--》比较多，但要用cache去优化）
 
 redis： cache thru 
 web server ->[ cache-->DB]: redis has cache and DB together 
 
 cache aside: 
 web server -> cache
          --->DB
 
 
 
 friendship service
 
one-way: 
 from_user_id Foreign_key
 To_user_id Foreign_key
 
 two way:
 saved as 2 seperate relations
 or saved as 1 relations, but need to query twice 
 
 which is better?
 normally both are ok, however, if need to have transaction operation for db, have to use SQL because NOSQL cannot support it 
 reason is: NOSQL, those two data, maybe in different machines 
 
 index have to set two, one is from_user_id, to_user_id, 
 index have to setup in db? (can binary search something, can be faster). use B+ tree in mySQL
 
 what is the diff between tree map and hash implementation? 
 hash_index cannot support range query, tree index supports range query 
 
 noSQL: have to do serialization and secondary index by user himself
 
 noSQL can do sharding for you, if you need to save your db in serveral machines 
 

noSQL: cassandra

canssandra is a 3 layer noSQL db
1 layer: row_key (hash_key), key-value zhong de key, cannot do range query use this 
2 layer: column_key, can be sorted, can use range query. can be combined: for eg: timestamp + user_id 
3 layer: value.  mostly is string, you can do serialization by yourself. 


SQL: data is shown as oen row 

NOSQL: data is shown as a grid 

normally newsFeed use NOSQL to store

How to scale? 

except QPS, whatelse we need to considder?

single point Failure?
 Sharding
  use some method and make the data in different machine, even if one machine is dead, not 100% web cannot work
 replica:
  duplicatd 3 times, sometimes used for reading server
  
SQL, doesn't have sharding function 
NOSQL: has sharding function itself

sharding:
vertical sharding:
 user table in one machine (or user table in one machine, user profile table in another machine)
 friendship table in one machine, message table in one machine
 
horizontal sharding
 for example, odd/even ID number  (or % number of machines) can be sperated in different machines.
  issue is the machine number is changing, may need to move a lot of data once adding one more machine (need to use consisten hashing)
  
 location based seperation 
 
user table
put in SQL for most of the companies, (confidence level, mysql used many years, mongoDB is very young, once lost a lot of data in one time)
use the username, email, phone == a lot of times, SQL can support this operation 

if we sharding user table using userID, DB0, DB1, DB2, then how to support operation like: email == "*gmail"?

can setup a new table to map email to use_id, because the info is very little, can cache all the info

why secondary index cannot work?
because you need to search all the dbs, very slow 







